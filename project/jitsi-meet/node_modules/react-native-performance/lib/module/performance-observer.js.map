{"version":3,"sources":["performance-observer.ts"],"names":["PerformanceObserverEntryList","constructor","entries","getEntries","slice","getEntriesByType","type","filter","entry","entryType","getEntriesByName","name","SUPPORTED_ENTRY_TYPES","sortByStartTime","a","b","startTime","OBSERVER_TYPE_SINGLE","OBSERVER_TYPE_MULTIPLE","createPerformanceObserver","addEventListener","removeEventListener","PerformanceObserver","callback","takeRecords","entryTypes","has","buffer","push","scheduleEmission","timer","Set","observerType","requestAnimationFrame","emitRecords","observe","options","TypeError","Error","Array","isArray","buffered","console","warn","add","forEach","includes","receiveRecord","disconnect","cancelAnimationFrame","sort"],"mappings":"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","sourcesContent":["import type { EntryType, PerformanceEntry } from './performance-entry';\n\ntype ObserveOptionType1 = {\n  entryTypes: EntryType[];\n};\n\ntype ObserveOptionType2 = {\n  type: EntryType;\n  buffered?: boolean;\n};\n\nexport class PerformanceObserverEntryList {\n  entries: PerformanceEntry[];\n\n  constructor(entries: PerformanceEntry[]) {\n    this.entries = entries;\n  }\n\n  getEntries() {\n    return this.entries.slice(0);\n  }\n\n  getEntriesByType(type: EntryType) {\n    return this.entries.filter((entry) => entry.entryType === type);\n  }\n\n  getEntriesByName(name: string, type?: EntryType) {\n    return this.entries.filter(\n      (entry) => entry.name === name && (!type || entry.entryType === type)\n    );\n  }\n}\n\nconst SUPPORTED_ENTRY_TYPES = [\n  'mark',\n  'measure',\n  'metric',\n  'react-native-mark',\n  'resource',\n];\n\nconst sortByStartTime = (a, b) => a.startTime - b.startTime;\n\nconst OBSERVER_TYPE_SINGLE = 'single';\nconst OBSERVER_TYPE_MULTIPLE = 'multiple';\n\nexport const createPerformanceObserver = ({\n  addEventListener,\n  removeEventListener,\n  getEntriesByType,\n}) =>\n  class PerformanceObserver {\n    callback: (\n      list: PerformanceObserverEntryList,\n      observer: PerformanceObserver\n    ) => void;\n    buffer: PerformanceEntry[];\n    entryTypes: Set<EntryType>;\n    timer?: number;\n    observerType:\n      | null\n      | typeof OBSERVER_TYPE_SINGLE\n      | typeof OBSERVER_TYPE_MULTIPLE;\n\n    static supportedEntryTypes = SUPPORTED_ENTRY_TYPES;\n\n    constructor(\n      callback: (\n        list: PerformanceObserverEntryList,\n        observer: PerformanceObserver\n      ) => void\n    ) {\n      this.callback = callback;\n      this.buffer = [];\n      this.timer = null;\n      this.entryTypes = new Set();\n      this.observerType = null;\n    }\n\n    emitRecords = () => {\n      this.callback(new PerformanceObserverEntryList(this.takeRecords()), this);\n    };\n\n    scheduleEmission() {\n      if (this.timer === null) {\n        this.timer = requestAnimationFrame(() => {\n          this.timer = null;\n          this.emitRecords();\n        });\n      }\n    }\n\n    receiveRecord = (entry: PerformanceEntry) => {\n      if (this.entryTypes.has(entry.entryType)) {\n        this.buffer.push(entry);\n        this.scheduleEmission();\n      }\n    };\n\n    observe(options: ObserveOptionType1): void;\n    observe(options: ObserveOptionType2): void;\n\n    observe(options: any) {\n      if (!options || (!options.entryTypes && !options.type)) {\n        throw new TypeError(\n          \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must include either entryTypes or type arguments.\"\n        );\n      }\n      if (options.entryTypes && options.type) {\n        throw new TypeError(\n          \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and type arguments.\"\n        );\n      }\n\n      if (options.entryTypes) {\n        if (this.observerType === OBSERVER_TYPE_SINGLE) {\n          throw new Error(\n            'This PerformanceObserver has performed observe({type:...}, therefore it cannot perform observe({entryTypes:...})'\n          );\n        }\n        if (!Array.isArray(options.entryTypes)) {\n          throw new TypeError('entryTypes argument must be an array');\n        }\n        this.observerType = OBSERVER_TYPE_MULTIPLE;\n        this.entryTypes = new Set(options.entryTypes);\n        this.buffer = [];\n        if (options.buffered) {\n          console.warn(\n            'The PerformanceObserver does not support buffered flag with the entryTypes argument.'\n          );\n        }\n      } else {\n        if (this.observerType === OBSERVER_TYPE_MULTIPLE) {\n          throw new Error(\n            'This PerformanceObserver has performed observe({entryTypes:...}, therefore it cannot perform observe({type:...})'\n          );\n        }\n        this.observerType = OBSERVER_TYPE_SINGLE;\n        this.entryTypes.add(options.type);\n        if (options.buffered) {\n          this.buffer = getEntriesByType(options.type);\n          this.scheduleEmission();\n        }\n      }\n\n      this.entryTypes.forEach((entryType) => {\n        if (!SUPPORTED_ENTRY_TYPES.includes(entryType)) {\n          console.warn(\n            `The entry type '${entryType}' does not exist or isn't supported.`\n          );\n        }\n      });\n\n      addEventListener(this.receiveRecord);\n    }\n\n    disconnect() {\n      removeEventListener(this.receiveRecord);\n      this.entryTypes = new Set();\n      this.observerType = null;\n      this.buffer = [];\n      if (this.timer !== null) {\n        cancelAnimationFrame(this.timer);\n        this.timer = null;\n      }\n    }\n\n    takeRecords() {\n      const entries = this.buffer.sort(sortByStartTime);\n      this.buffer = [];\n      return entries;\n    }\n  };\n"]}