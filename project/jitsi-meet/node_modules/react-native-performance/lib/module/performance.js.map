{"version":3,"sources":["performance.ts"],"names":["createEventEmitter","createPerformanceObserver","PerformanceMark","PerformanceMeasure","PerformanceMetric","defaultNow","global","performance","now","createPerformance","timeOrigin","addEventListener","removeEventListener","emit","marks","Map","entries","addEntry","entry","push","entryType","set","name","startTime","removeEntries","type","filter","delete","mark","markName","markOptions","undefined","detail","clearMarks","clearMeasures","clearMetrics","convertMarkToTimestamp","markOrTimestamp","has","Error","get","TypeError","measure","measureName","startOrMeasureOptions","endMark","start","end","constructor","Object","duration","metric","valueOrOptions","value","getEntries","slice","getEntriesByName","getEntriesByType","PerformanceObserver"],"mappings":"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","sourcesContent":["import { createEventEmitter } from './event-emitter';\nimport { createPerformanceObserver } from './performance-observer';\nimport {\n  EntryType,\n  PerformanceMark,\n  PerformanceMeasure,\n  PerformanceMetric,\n  PerformanceEntry,\n  PerformanceReactNativeMark,\n  PerformanceResourceTiming,\n} from './performance-entry';\n\n// @ts-ignore\nexport const defaultNow = (): number => global.performance.now();\n\nexport type MarkOptions = {\n  startTime?: number;\n  detail?: any;\n};\n\nexport type MeasureOptions = {\n  start?: string | number;\n  end?: string | number;\n  duration?: number;\n  detail?: any;\n};\n\nexport type StartOrMeasureOptions = string | MeasureOptions | undefined;\n\nexport type MetricOptions = {\n  startTime: number;\n  detail: any;\n  value: number | string;\n};\n\nexport type ValueOrOptions = number | string | MetricOptions;\n\nexport const createPerformance = (now: () => number = defaultNow) => {\n  const timeOrigin = now();\n  const {\n    addEventListener,\n    removeEventListener,\n    emit,\n  } = createEventEmitter<PerformanceEntry>();\n  const marks = new Map<string, number>();\n  let entries: PerformanceEntry[] = [];\n\n  function addEntry<T extends PerformanceEntry>(entry: T): T {\n    entries.push(entry);\n    if (entry.entryType === 'mark' || entry.entryType === 'react-native-mark') {\n      marks.set(entry.name, entry.startTime);\n    }\n    emit(entry);\n    return entry;\n  }\n\n  const removeEntries = (type: EntryType, name?: string) => {\n    entries = entries.filter((entry) => {\n      if (entry.entryType === type && (!name || entry.name === name)) {\n        marks.delete(entry.name);\n        return false;\n      }\n      return true;\n    });\n  };\n\n  const mark = (markName: string, markOptions: MarkOptions = {}) =>\n    addEntry(\n      new PerformanceMark(markName, {\n        startTime:\n          'startTime' in markOptions && markOptions.startTime !== undefined\n            ? markOptions.startTime\n            : now(),\n        detail: markOptions.detail,\n      })\n    );\n\n  const clearMarks = (name?: string) => removeEntries('mark', name);\n\n  const clearMeasures = (name?: string) => removeEntries('measure', name);\n\n  const clearMetrics = (name?: string) => removeEntries('metric', name);\n\n  const convertMarkToTimestamp = (markOrTimestamp: string | number) => {\n    switch (typeof markOrTimestamp) {\n      case 'string': {\n        if (!marks.has(markOrTimestamp)) {\n          throw new Error(\n            `Failed to execute 'measure' on 'Performance': The mark '${markOrTimestamp}' does not exist.`\n          );\n        }\n        return marks.get(markOrTimestamp);\n      }\n      case 'number': {\n        return markOrTimestamp;\n      }\n      default:\n        throw new TypeError(\n          `Failed to execute 'measure' on 'Performance': Expected mark name or timestamp, got '${markOrTimestamp}'.`\n        );\n    }\n  };\n\n  const measure = (\n    measureName: string,\n    startOrMeasureOptions?: StartOrMeasureOptions,\n    endMark?: string | number\n  ) => {\n    let start = 0;\n    let end = 0;\n    let detail: any;\n\n    if (\n      startOrMeasureOptions &&\n      typeof startOrMeasureOptions === 'object' &&\n      startOrMeasureOptions.constructor == Object\n    ) {\n      if (endMark) {\n        throw new TypeError(\n          `Failed to execute 'measure' on 'Performance': The measureOptions and endMark arguments may not be combined.`\n        );\n      }\n      if (!startOrMeasureOptions.start && !startOrMeasureOptions.end) {\n        throw new TypeError(\n          `Failed to execute 'measure' on 'Performance': At least one of the start and end option must be passed.`\n        );\n      }\n      if (\n        startOrMeasureOptions.start &&\n        startOrMeasureOptions.end &&\n        startOrMeasureOptions.duration\n      ) {\n        throw new TypeError(\n          `Failed to execute 'measure' on 'Performance': Cannot send start, end and duration options together.`\n        );\n      }\n\n      detail = startOrMeasureOptions.detail;\n\n      if (startOrMeasureOptions && startOrMeasureOptions.end) {\n        end = convertMarkToTimestamp(startOrMeasureOptions.end);\n      } else if (\n        startOrMeasureOptions &&\n        startOrMeasureOptions.start &&\n        startOrMeasureOptions.duration\n      ) {\n        end =\n          convertMarkToTimestamp(startOrMeasureOptions.start) +\n          convertMarkToTimestamp(startOrMeasureOptions.duration);\n      } else {\n        end = now();\n      }\n\n      if (startOrMeasureOptions && startOrMeasureOptions.start) {\n        start = convertMarkToTimestamp(startOrMeasureOptions.start);\n      } else if (\n        startOrMeasureOptions &&\n        startOrMeasureOptions.end &&\n        startOrMeasureOptions.duration\n      ) {\n        start =\n          convertMarkToTimestamp(startOrMeasureOptions.end) -\n          convertMarkToTimestamp(startOrMeasureOptions.duration);\n      } else {\n        start = timeOrigin;\n      }\n    } else {\n      if (endMark) {\n        end = convertMarkToTimestamp(endMark);\n      } else {\n        end = now();\n      }\n\n      if (typeof startOrMeasureOptions === 'string') {\n        start = convertMarkToTimestamp(startOrMeasureOptions);\n      } else {\n        start = timeOrigin;\n      }\n    }\n\n    return addEntry(\n      new PerformanceMeasure(measureName, {\n        detail,\n        startTime: start,\n        duration: end - start,\n      })\n    );\n  };\n\n  const metric = (name: string, valueOrOptions: ValueOrOptions) => {\n    let value: string | number;\n    let startTime: number | undefined;\n    let detail: any;\n\n    if (\n      typeof valueOrOptions === 'object' &&\n      valueOrOptions.constructor == Object\n    ) {\n      if (!valueOrOptions.value) {\n        throw new TypeError(\n          `Failed to execute 'metric' on 'Performance': The value option must be passed.`\n        );\n      }\n      value = valueOrOptions.value;\n      startTime = valueOrOptions.startTime;\n      detail = valueOrOptions.detail;\n    } else if (\n      typeof valueOrOptions === 'undefined' ||\n      valueOrOptions === null\n    ) {\n      throw new TypeError(\n        `Failed to execute 'metric' on 'Performance': The value option must be passed.`\n      );\n    } else {\n      value = valueOrOptions as string | number;\n    }\n\n    return addEntry(\n      new PerformanceMetric(name, {\n        startTime: startTime ? startTime : now(),\n        value,\n        detail,\n      })\n    );\n  };\n\n  const getEntries = () => entries.slice(0);\n\n  const getEntriesByName = (name: string, type?: EntryType) =>\n    entries.filter(\n      (entry) => entry.name === name && (!type || entry.entryType === type)\n    );\n\n  function getEntriesByType(type: 'measure'): PerformanceMeasure[];\n  function getEntriesByType(type: 'mark'): PerformanceMark[];\n  function getEntriesByType(type: 'resource'): PerformanceResourceTiming[];\n  function getEntriesByType(type: 'metric'): PerformanceMetric[];\n  function getEntriesByType(\n    type: 'react-native-mark'\n  ): PerformanceReactNativeMark[];\n  function getEntriesByType(type: EntryType) {\n    return entries.filter((entry) => entry.entryType === type);\n  }\n\n  const PerformanceObserver = createPerformanceObserver({\n    addEventListener,\n    removeEventListener,\n    getEntriesByType,\n  });\n\n  return {\n    PerformanceObserver,\n    addEntry,\n    performance: {\n      timeOrigin,\n      now,\n      mark,\n      clearMarks,\n      measure,\n      clearMeasures,\n      metric,\n      clearMetrics,\n      getEntries,\n      getEntriesByName,\n      getEntriesByType,\n    },\n  };\n};\n\nexport type Performance = ReturnType<typeof createPerformance>['performance'];\n"]}